import es.unizar.disco.pnml.utils.PnmlDiceUtils;
import uml2pnml;
import helpers;

modeltype UML uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype PNML uses 'http:///ptnet.ecore';
modeltype CONF uses 'http://es.unizar.disco/pnconfig/1.0';
modeltype CONST uses 'http://es.unizar.disco/pnconstants/1.0';
	

transformation ad2pnml(in ad : UML, in config : CONF, out res : PNML) 
extends uml2pnml();

main() {
	new uml2pnml(ad, config, res)->transform();
	ad.objectsOfType(UML::ControlFlow)->map abstractControlFlow2subNet();
	if (config.rootObjects()[CONF::PetriNetConfig]->asOrderedSet()->first().analysisType = CONF::AnalysisType::steadyState) {
		map net2steadyStateNet();
	};
}


mapping net2steadyStateNet() {
	init {
	-- transientFlow is a temporary ControlFlow that eases the creation of the 
	-- closing loop for the SteadyState Analysis 
		var transientFlow := object UML::ControlFlow {
			source := ad.objectsOfKind(UML::FinalNode)->asOrderedSet()->first();
			target := ad.objectsOfKind(UML::InitialNode)->asOrderedSet()->first();
		}
	}
	transientFlow->map abstractControlFlow2subNet();
	-- The transientFlow is created, by default, in the output model
	-- We must delete it 
	res.removeElement(transientFlow);
}

mapping UML::ControlFlow::abstractControlFlow2subNet()
disjuncts 
UML::ControlFlow::preJoinControlFlow2subNet, 
UML::ControlFlow::postJoinControlFlow2subNet, 
UML::ControlFlow::decissionControlFlow2subNet,
UML::ControlFlow::closingControlFlow2subNet,
UML::ControlFlow::singleControlFlow2subNet
{
}


mapping UML::ControlFlow::singleControlFlow2subNet()
{
	var place1 := self.source.map namedElement2place(self.source.safeId());
	var place2 := self.target.map namedElement2place(self.target.safeId());
	
	var trans := self.source.map namedElement2transition('t_' + self.source.safeId());
	
	var arc1 := self.map namedElement2arc(place1, trans);
	var arc2 := self.map namedElement2arc(trans, place2);

}

mapping UML::ControlFlow::preJoinControlFlow2subNet()
when {
	 self.source.oclIsKindOf(UML::ActivityNode) 
	 and
	 self.target.oclIsKindOf(UML::JoinNode) 
}
{
	var place1 := self.source.map namedElement2place(self.source.safeId());
	var place2 := self.target.map namedElement2place(self.source.safeId() + '-' + self.target.safeId());
	
	var trans1 := self.source.map namedElement2transition('t_' + self.source.safeId());
	var trans2 := self.target.map namedElement2transition('t_' + self.target.safeId());
	
	self.map namedElement2arc(place1, trans1);
	self.map namedElement2arc(trans1, place2);
	self.map namedElement2arc(place2, trans2);
}

mapping UML::ControlFlow::postJoinControlFlow2subNet()
when {
	 self.source.oclIsKindOf(UML::JoinNode) 
	 and
	 self.target.oclIsKindOf(UML::ActivityNode) 
}
{
	var place2 := self.target.map namedElement2place(self.target.safeId());
	
	var trans := self.source.map namedElement2transition('t_' + self.source.safeId());
	
	self.map namedElement2arc(trans, place2);
}

mapping UML::ControlFlow::decissionControlFlow2subNet()
when {
	 self.source.oclIsKindOf(UML::DecisionNode) 
	 and
	 self.target.oclIsKindOf(UML::ActivityNode) 
}
{
	var place1 := self.source.map namedElement2place(self.source.safeId());
	var place2 := self.target.map namedElement2place(self.target.safeId());
	
	var trans := self.map namedElement2transition('t_' + self.source.safeId() + '-' + self.target.safeId());
	
	self.map namedElement2arc(place1, trans);
	self.map namedElement2arc(trans, place2);
}

mapping UML::ControlFlow::closingControlFlow2subNet()
when {
	 self.source.oclIsKindOf(UML::FinalNode) 
	 and
	 self.target.oclIsKindOf(UML::InitialNode) 
}
{
	var place1 := self.source.map namedElement2place(self.source.safeId());
	var place2 := self.target.map namedElement2place(self.target.safeId());
	
	var trans := self.map namedElement2transition('close');
	
	self.map namedElement2arc(place1, trans);
	self.map namedElement2arc(trans, place2);
}
