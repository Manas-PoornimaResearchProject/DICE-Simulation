import es.unizar.disco.pnml.utils.PnmlDiceUtils;
import uml2pnml;
import helpers;

modeltype UML uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype PNML uses 'http:///ptnet.ecore';
modeltype INVOC uses 'http://es.unizar.disco/simulation/invocation/1.0';
modeltype CONST uses 'http://es.unizar.disco/pnconstants/1.0';
	

transformation ad2pnml(in invocation : INVOC, out res : PNML) 
extends uml2pnml();

intermediate class ArrivalPattern {
}

constructor ClosedPattern::ClosedPattern() {};
intermediate class ClosedPattern extends ArrivalPattern {
	population_ : Integer;
	extDelay : Real;
}

helper UML::NamedElement::getGaWorkloadEvent_pattern() : ArrivalPattern
{
	var stereotype := self.getAppliedStereotype("MARTE::MARTE_AnalysisModel::GQAM::GaWorkloadEvent");
	if (stereotype != null) {
		var patternString := self.getValue(stereotype, "pattern").oclAsType(String);
		if (patternString != null) {
			if (patternString.key() = "closed") {
				var pattern := new ClosedPattern();
				pattern.population_ := patternString.value().getNfpValue("population").toInteger();
				pattern.extDelay := patternString.value().getNfpValue("extDelay").toReal();
				return pattern;
			} else {
				abort("Unknown ArrivalPattern: " + patternString);
			}
		}
	};
	return null;
}


main() {
	new uml2pnml(invocation, res)->transform();
	invocation.activeScenario().edge->selectByKind(UML::ControlFlow) -> map abstractControlFlow2subNet();
	var initialNodes := invocation.activeScenario().initialNodes();
	if (initialNodes->size() <> 1) {
		abort("Only Activities with a single Initial Node are supported");
	};
	var initialNode := initialNodes->first();
	var pattern := initialNode.getGaWorkloadEvent_pattern();
	if (pattern.oclIsTypeOf(ClosedPattern)) {
		initialNode.map net2steadyStateNet();
	}
}


mapping UML::InitialNode::net2steadyStateNet() {
	init {
	-- transientFlow is a temporary ControlFlow that eases the creation of the 
	-- closing loop for the SteadyState Analysis 
		if (invocation.activeScenario().finalNodes()->size() <> 1) {
			abort("Only Activities with a single Final Node are supported");
		};
		var transientFlow := object UML::ControlFlow {
			source := invocation.activeScenario().finalNodes()->first();
			target := self;
		}
	}
	transientFlow->map abstractControlFlow2subNet();
	-- The transientFlow is created, by default, in the output model
	-- We must delete it 
	res.removeElement(transientFlow);
}


mapping UML::ControlFlow::abstractControlFlow2subNet()
disjuncts 
UML::ControlFlow::preJoinControlFlow2subNet, 
UML::ControlFlow::postJoinControlFlow2subNet, 
UML::ControlFlow::decissionControlFlow2subNet,
UML::ControlFlow::closingControlFlow2subNet,
UML::ControlFlow::singleControlFlow2subNet
{
}


mapping UML::ControlFlow::singleControlFlow2subNet()
{
	var place1 := self.source.map namedElement2place(self.source.safeId());
	var place2 := self.target.map namedElement2place(self.target.safeId());
	
	var trans := self.source.map namedElement2transition('t_' + self.source.safeId());
	
	var arc1 := self.map namedElement2arc(place1, trans);
	var arc2 := self.map namedElement2arc(trans, place2);

}

mapping UML::ControlFlow::preJoinControlFlow2subNet()
when {
	 self.source.oclIsKindOf(UML::ActivityNode) 
	 and
	 self.target.oclIsKindOf(UML::JoinNode) 
}
{
	var place1 := self.source.map namedElement2place(self.source.safeId());
	var place2 := self.target.map namedElement2place(self.source.safeId() + '-' + self.target.safeId());
	
	var trans1 := self.source.map namedElement2transition('t_' + self.source.safeId());
	var trans2 := self.target.map namedElement2transition('t_' + self.target.safeId());
	
	self.map namedElement2arc(place1, trans1);
	self.map namedElement2arc(trans1, place2);
	self.map namedElement2arc(place2, trans2);
}

mapping UML::ControlFlow::postJoinControlFlow2subNet()
when {
	 self.source.oclIsKindOf(UML::JoinNode) 
	 and
	 self.target.oclIsKindOf(UML::ActivityNode) 
}
{
	var place2 := self.target.map namedElement2place(self.target.safeId());
	
	var trans := self.source.map namedElement2transition('t_' + self.source.safeId());
	
	self.map namedElement2arc(trans, place2);
}

mapping UML::ControlFlow::decissionControlFlow2subNet()
when {
	 self.source.oclIsKindOf(UML::DecisionNode) 
	 and
	 self.target.oclIsKindOf(UML::ActivityNode) 
}
{
	var place1 := self.source.map namedElement2place(self.source.safeId());
	var place2 := self.target.map namedElement2place(self.target.safeId());
	
	var trans := self.map namedElement2transition('t_' + self.source.safeId() + '-' + self.target.safeId());
	
	self.map namedElement2arc(place1, trans);
	self.map namedElement2arc(trans, place2);
}

mapping UML::ControlFlow::closingControlFlow2subNet()
when {
	 self.source.oclIsKindOf(UML::FinalNode) 
	 and
	 self.target.oclIsKindOf(UML::InitialNode) 
}
{
	var place1 := self.source.map namedElement2place(self.source.safeId());
	var place2 := self.target.map namedElement2place(self.target.safeId());
	
	var trans := self.map namedElement2transition('close');
	
	self.map namedElement2arc(place1, trans);
	self.map namedElement2arc(trans, place2);
}


helper INVOC::currentInvocation() : INVOC::SimulationInvocation {
	return self.objectsOfType(INVOC::SimulationInvocation)->asSequence()->first();
}

helper INVOC::activeScenario() : UML::Activity {
	return self.currentInvocation().definition.activeScenario.oclAsType(UML::Activity);
}

helper UML::Activity::initialNodes() : OrderedSet (UML::InitialNode) {
	return invocation.activeScenario().node->selectByKind(UML::InitialNode)->asOrderedSet();
}

helper UML::Activity::finalNodes() : OrderedSet (UML::FinalNode) {
	return invocation.activeScenario().node->selectByKind(UML::FinalNode)->asOrderedSet();
}